#!/usr/bin/env bash

##
# Remote host-related utility functions.
#
# This file is dynamically loaded.
# @see cwt/bootstrap.sh
#

##
# Executes local scripts remotely.
#
# @param 1 String : remote instance's id (short name, no space, _a-zA-Z0-9 only).
# @param 2 String : file path to local script to execute remotely.
# @param ... The rest will be forwarded to the script.
#
# @prereq manual setup on remote.
# @prereq u_remote_instance_add() already launched locally at least once.
#
# @example
#   u_remote_script_wrapper 'my_short_id' cwt/stack/init.sh -s drupal-7
#
u_remote_script_wrapper() {
  local p_id="$1"
  local p_local_script_to_exec_remotely="$2"
  shift 2

  if [[ ! -f "$p_local_script_to_exec_remotely" ]]; then
    echo
    echo "Error in $BASH_SOURCE line $LINENO: file '$p_local_script_to_exec_remotely' not found." >&2
    echo "Aborting (1)." >&2
    echo
    return 1
  fi

  u_remote_instance_load "$p_id"

  if [[ -z "$REMOTE_INSTANCE_CONNECT_CMD" ]]; then
    echo
    echo "Error in $BASH_SOURCE line $LINENO: no conf found for remote id '$p_id'." >&2
    echo "Aborting (2)." >&2
    echo
    return 2
  fi

  # Remote execution wrapper.
  # See https://unix.stackexchange.com/a/326672 (using the bash or ksh version).
  if [[ -n "$@" ]]; then
    local args
    printf -v args '%q ' "$@"

    eval "$REMOTE_INSTANCE_CONNECT_CMD \"cd $REMOTE_INSTANCE_PROJECT_DOCROOT && bash -s -- $args\" < \"$p_local_script_to_exec_remotely\""

  else
    eval "$REMOTE_INSTANCE_CONNECT_CMD \"cd $REMOTE_INSTANCE_PROJECT_DOCROOT && bash -s\" < \"$p_local_script_to_exec_remotely\""
  fi
}

##
# Adds a remote instance.
#
# TODO prevent for instances where HOST_TYPE != 'local' ?
#
# @param 1 String : remote instance's id (short name, no space, _a-zA-Z0-9 only).
# @param 2 String : remote instance's host domain.
# @param 3 String : remote instance's type (dev, production, etc).
# @param 4 String : remote instance's host connection command.
# @param 5 String : remote instance's PROJECT_DOCROOT value.
# @param 6 [optional] String : remote instance's APP_DOCROOT value. Defaults to:
#   "$p_project_docroot/web"
#
# @example
#   # Basic example with only mandatory params :
#   u_remote_instance_add \
#     'my_short_id' \
#     'remote.instance.cwt.com' \
#     'dev' \
#     'ssh -p123 username@cwt.com' \
#     '/path/to/remote/instance/docroot'
#
u_remote_instance_add() {
  local p_id="$1"
  local p_host="$2"
  local p_type="$3"
  local p_connect_cmd="$4"
  local p_project_docroot="$5"
  local p_app_docroot="$6"

  if [[ -z "$p_app_docroot" ]]; then
    p_app_docroot="$p_project_docroot/web"
  fi

  local conf="cwt/remote/instances/${p_id}.sh"

  # Confirm overwriting existing config if the file already exists.
  if [[ -f "$conf" ]]; then
    echo
    while true; do
      echo "It seems the file '$conf' already exists."
      read -p "Overwrite ? (y/n) : " yn
      case $yn in
        [Yy]* ) echo "Ok, proceeding to override existing settings."; break;;
        [Nn]* ) echo "Aborting (1)."; return 1;;
        * ) echo "Please answer yes (enter 'y') or no (enter 'n').";;
      esac
    done
  fi

  # (Re)init destination file (make empty).
  cat > "$conf" <<'EOF'
#!/usr/bin/env bash

##
# Remote instance config file.
#
# This file is automatically generated.
# @see u_remote_instance_add()
#

EOF

  # TODO remove dead code.
  # p_connect_cmd="$(printf "%s" "$p_connect_cmd" | base64)"

  printf "%s" "export REMOTE_INSTANCE_ID='$p_id'" >> "$conf"
  printf "%s" "export REMOTE_INSTANCE_HOST='$p_host'" >> "$conf"
  printf "%s" "export REMOTE_INSTANCE_TYPE='$p_type'" >> "$conf"
  printf "%s" "export REMOTE_INSTANCE_CONNECT_CMD='$p_connect_cmd'" >> "$conf"
  printf "%s" "export REMOTE_INSTANCE_PROJECT_DOCROOT='$p_project_docroot'" >> "$conf"
  printf "%s" "export REMOTE_INSTANCE_APP_DOCROOT='$p_app_docroot'" >> "$conf"
}

##
# Gets remote instance config.
#
# @param 1 [optional] String : remote instance's id (short name, no space,
#   _a-zA-Z0-9 only). Defaults to the first *.sh file found in folder :
#   cwt/remote/instances.
#
# @exports REMOTE_INSTANCE_ID
# @exports REMOTE_INSTANCE_HOST
# @exports REMOTE_INSTANCE_TYPE
# @exports REMOTE_INSTANCE_CONNECT_CMD
# @exports REMOTE_INSTANCE_PROJECT_DOCROOT
# @exports REMOTE_INSTANCE_APP_DOCROOT
#
# @example
#   # Only need to call the function for exporting globals in current shell :
#   u_remote_instance_load 'my_short_id'
#
u_remote_instance_load() {
  local p_id="$1"
  local conf="cwt/remote/instances/${p_id}.sh"

  if [[ ! -f "$conf" ]]; then
    echo
    echo "Error in $BASH_SOURCE line $LINENO: file '$conf' not found." >&2
    echo "Aborting (1)." >&2
    echo
    return 1
  fi

  . "$conf"
}
